
For SetupInstructions REFER : "SetupInstructions.docx"


If "node_modules" is not found under cur dir of project, it will move to parent dir, if still not parent dir....


In Traditional app, Client side only understands HTML, full load is on web server
In SPA, only index.html is loaded from web server, all JS, CSS is downloaded and kept ready on client side (browser).


ANGULAR vs REACT
=========================
-ANGULAR is a FRAMEWORK , REACT is a UI LIBRARY which requires different packages to work with for complete application
-ANGULAR is HTML centric , REACT is JS centric
-ANGULAR is backed by GOOGLE , REACT is backed by FACEBOOK
-both differs in their internal architecture.


REAL DOM vs VIRTUAL DOM
============================
DO NOT USE JQuery DOM   or  JAVASCRIPT DOM API directly as they work on (REAL DOM) BROWSER DOM which makes application slower.
Instead use REACT DOM API which will use VIRTUAL DOM.
VIRTUAL DOM is a JS Object, an in memory representation of of REAL DOM (BROWSER DOM), which are faster than DOM Objects.
REACT DOM API never reads from REAL DOM.
Any changes do happen in VIRTUAL DOM only, React then compares VIRTUAL and REAL DOM and only make difference in two to be implemented in REAL DOM.


JSX | BABEL
====================
JSX is Javascript extension, it looks like HTML but is not actually HTML.
JSX is a static HTML + dynamic stuff
JSX is XML like syntax JavaScript, that is provided by REACT.
BABEL makes conversion of JSX to HTML and JS possible as browser understands only HTML and JS.

REACT creates a VIRTUAL DOM within <script type="text/babel"> ... </script> tag.
This type attribute of <script> specifies to BABEL that take JSX and convert to HTML.

".render" provides VIRTUAL DOM to be copied to BROWSER DOM , using args "what to render" and "where to render".
EVERY REACT component must have a "render" method.
 
".createElement" creates HTML tags using args "tag name", "attribute vals", "value within tag  OR  .createElement of other nested tag".

".createClass" provides JSX syntax for rendering elements ie "what to render", stored in a variable "ReactComponent" (NOTE: REACT vars are in UpperCase)



NEW PROJECT using tool
=======================
- npm install -g create-react-app
- create-react-app APPNAME

CHECK package.json for these options
======================================
  npm start
    Starts the development server.
    similar to "ng serve"

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you cant go back!
    
    
npm start
============
/* To run react application on a different port , there are two ways */
/*1 */
/* set ENV PORT in package.json */
   "start": "set PORT=4000 && react-scripts start"                                 
      OR
/*2*/
/* set PORT in `node_modules/react-scripts/scripts/start.js` */
   const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 4000;


/* To prevent browser from opening on npm start , comment a line in `node_modules/react-scripts/scripts/start.js` */ 
   //openBrowser(urls.localUrlForBrowser);



PROJECT STRUCTURE
=======================
"package.json"
------------------
- "name" | "dependencies" | "scripts"

"index.html"
------------------
- located inside  'public'  dir
- <div id="cont"></div>                          ,  provides "where to render"
- <script src="./dist/bundle.js"></script> ,  take all JS from all dirs in cur dir and bundle it to a bundle called bundle.js

"index.js"
------------------
- located inside  'src'  dir
- IMPORT statements
- .render(WhatToRender , WhereToRender)
   ReactDOM.render(
   <React.StrictMode>
     <App />
   </React.StrictMode>,  document.getElementById('root'));

"index.css"
----------------------------------------------------
- located inside  'src'  dir
- similar to global `styles.css` in angular

"App.js" , "App.css"
----------------------
- located inside  'src'  dir
- Similar to `AppComponent` in angular

"webpack.config.js" file to CREATE a BUNDLE.js
---------------------------------------------------
ANGULAR CLI also internally uses WEBPACK.
To run webpack.config.js to create bundle command  ,  > webpack --mode=development
module.exports = {
entry: './src/main.js',
output: {
	filename: 'bundle.js',
	path: __dirname + '/dist'
}, 
module: {
	rules: [
		{		
		test: /\.js$/,
		exclude: /node_modules/,
		loader: 'babel-loader',
		options: {
			presets: ['react']
		}
		}		
	]
}
};

in "dist" dir we have a "bundle.js" created
---------------------------------------------


SUMMARY
==========
1) Go to Node.js Cmd Prompt and to proper directory.
2) > webpack --mode=development -> Builds and create bundle.js in dist directory.
3) > hs                          > or http-server -> Simple http server - Port 8080 , similar to "ng serve"
4) Go to Google Chrome
5) http://localhost:8080/
6) Ctrl-Shift-J or F12   (JavaScript Console)

Working Flow
--------------
 "index.html"       (specify css link, js script, bundle path to use)
 "dist/bundle.js"   (specify entry point of application ie  "main.js" )
 "REACT COMPONENTS" (components called as per their call hierarchy)



Creating react components
============================
/* 1. CLASS  - React component */
import React from 'react';
export default class App extends React.Component {
	render() {
		return (
			<>
			<h1>Welcome to React!</h1>
			</>
		);
	}
}

/* 2. FUNCTIONAL - React  component */
import React from 'react';
function App() {
	return (
		<>
		<h1>Welcome to React!</h1>
		</>
	);
}
export default App;

/* 3. FUNCTIONAL using Arrow notation - React component  */
import React from 'react';
const App = () => {
	return (
		<>
		<h1>Welcome to React!</h1>
		</>
	);
}
export default App;


Component Reuse + Interpolation + PropertyBinding
===================================================
/* Similar to using component DIRECTIVE as used with child components in angular */
/* when reusing components , enclose them within a <div>...</div>  tag OR <React.Fragment>...</React.Fragment> OR <>...</> */
import React from 'react';
import ChildComp1 from './Childcomp_1';
import ChildComp2 from './Childcomp_2';
function App() {
	let i = 6;
	let logo = "<PATH_TO_IMAGE>";
	return (
		<p>{i * 5 + 7}</p>                                            // Interpolation, NOTE: use of single { }
		<img src={logo} className="App-logo" alt="logo" />            // Property Binding
		<React.Fragment>
			<ChildComp1/><ChildComp2/>
		</React.Fragment>
	);
}
export default App;



PROPERTIES (props)
===================
/* Similar to `@Input` concept in angular */
/* Properties are immutable i.e. we cannot assign props a value,   this.props.os = "Linux"; */
/* defaultProps can be used in absence of actual parameter values to be passed */
/* propTypes will get removed from production build of the application */
   /* Used only in developmental integration testing */
import React from 'react';
import PropTypes from 'prop-types';
import ChildComp1 from './Childcomp_1';
import ChildComp2 from './Childcomp_2';
ChildComp1.defaultProps = { VAR_1 : "JRK ji" };
ChildComp2.defaultProps = { VAR_1 : "Kapoor",  VAR_2 : ["ASR"] };
ChildComp2.propTypes = { VAR_1(props, propName) {
				if (typeof props[propName] !== "number") { return new Error("Age must be a number"); }
				if (props[propName] > 100) { return new Error("Age entered is " + props[propName] + ", it should be less than or equal to 100"); }
			 },
			 VAR_2 : PropTypes.array.isRequired
};
function App() {
	return (
		<React.Fragment>
			<ChildComp1 VAR_1={"Hardcoded_Val"}>CHILDREN_1</ChildComp1>
			<ChildComp2 VAR_1={Dynamic_Val} VAR_2={["JRK", "ASR"]}>CHILDREN_2</ChildComp2>
		</React.Fragment>
	);
}
export default App;

/* Childcomp_1 as FUNCTIONAL component */
/* NOTE : use of   'props'   (not a keyword, still good to write arg as is) as arg to function */
import React from 'react';
function ChildComp1(props) {
	return (
		<>
		<h1>Operating System: {props.VAR_1}</h1>              // "Hardcoded_Val"
		<h3>Developed by {props.children}</h3>                // '.children' keyword gives content within childcomp tag, example : CHILDREN_1
		</>
	);
}
export default ChildComp1;

/* Childcomp_2 as CLASS component */
/* NOTE : Use of   'this'  keyword */
import React from 'react';
class ChildComp2 extends React.Component {
	render() {
		return (
			<>
			<h1>Operating System: {this.props.VAR_1}</h1>     // Dynamic_Var_Value
			<h1>Operating System: {this.props.VAR_2}</h1>     // Array object
			<h3>Developed by {this.props.children}</h3>       // CHILDREN_2
			</>
		);
	}
}
export default ChildComp2;



EVENT HANDLING
===============
/* NOTE : Same events as of HTML , but with NAMING CONVENTION of camelCase for event handlers   onClick, onFocus, onBlur, onChange, onInput
	: Here we have not added () ie this.func1() because it will call the func everytime COMPONENT loads.
*/
/* 1. FUNCTIONAL component */
/* NOTE : Use 'function' keyword when defining functions */
/*      : Do not use 'this' keyword to access functions */
import React from 'react';
function ChildComp(props) {
	function handleText(et) {
		console.log(et.target.value);
	}    
	function add() {        
		console.log('Add clicked');    
	}
	function update(evt) {
		console.log(`${evt.target}`);
		console.log(`Update Clicked`);
	}
	return (
		<>
		<input type="text" onInput={(evt) => handleText(evt)}/>
		<button onClick={() => add()}>Add</button>
		<button onClick={update}>Update</button>
		</>
	);
}
export default ChildComp;

/* 2. CLASS component */
/* NOTE : Do not use 'function' keyword when defining functions */
/*      : Use 'this' keyword to access functions */
import React from 'react';
class ChildComp extends React.Component {
	handleText(et) {    
		console.log(et.target.value);    
	}    
	add() {        
		console.log('Add clicked');    
	}
	update(evt) {
		console.log(`${evt.target}`);
		console.log(`Update Clicked`);
	}
	render() {
	  return (
	  	<>
		<input type="text" onInput={(evt) => this.handleText(evt)}/>
		<button onClick={() => this.add()}>Add</button>
		<button onClick={this.update}>Update</button>
		</>
	  );
	}
}
export default ChildComp;



State (Controlled Components)
==============================
/* managing data using STATE */
/* When STATE changes, REACT compares virtual DOM to real DOM for change to take effect */    
   /* - Server responses , data that gets displayed on browser.         
      - Cached or buffered data.        
      - Computed or temporary data.        
      - UI controls like disabled button , selected tab , active route.    
   */
/* use `setState()` method to update STATE */
/* To update STATE using a previous value of STATE, make use of function inside setState */
import React from 'react';
export default class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			empname: 'Ram',
			bManager: false
		};
	}
	handleTextChange(e) {
		this.setState({ empname: e.target.value });
	}
		/* === Wrong way for setting state based on previous state value === */
		/*
		handleCheckbox() {
			this.setState({bManager: !this.state.bManager});
		}
		*/
	/* Correct way for setting state based on previous state value = Through Arrow function */
	handleCheckbox() {
		this.setState((prevState) => {      
				return ({ bManager: !prevState.bManager })    
			       }
		);
	}
	render() {
		let role = this.state.bManager ? " Manager" : " Employee";
		return (
			<>
			<input type="text" value={this.state.empname} onChange={(e) => this.handleTextChange(e)} />
			<input type="checkbox" checked={this.state.bManager} onChange={() => this.handleCheckbox()} />
			<p>{this.state.empname} is {role}</p>
			</>
		);
	}
}

Ref (Uncontrolled Components)
===============================
/* This is same as ElementRef in angular */
import React from 'react';
export default class App extends React.Component {
	constructor(props) {
		super(props);
		this.refName = React.createRef();
		this.refLocation = React.createRef();
	}
	handleSubmit() {
		let name = this.refName.current.value;
		let location = this.refLocation.current.value;
		console.log(`Name = ${name}, Location = ${location}`);
		this.refName.current.focus();
	}
	render() {
		return (
			<>
			<label>Enter your name:<input type="text" ref={this.refName} /><br/><br/></label>
			<label>Enter your location:<input type="text" ref={this.refLocation} /><br/><br/></label>
			<button onClick={() => this.handleSubmit()}>Submit</button>
			</>
		);
	}
}



Component Lifecycle
======================
- constructor() {}

- render() {}
/* Mandatory  to be implemented in ES2015 class components */
/* It returns the DOM to be rendered */
/* React achieves fast and responsive UI by re-rendering components on every state change (using .setState) or from changes of props */

- componentDidMount() {}
/* similar to ngOninit()/ngAfterViewInit() in angular */
/* Called after initial render() , only once when component's DOM exists */
/* We should attach Event Handlers here , as DOM is initially rendered completely */
/* We should make network HTTP GET request here ( not in constructor() ) to retrieve data , then call this.setState() method to re-render component */

- componentDidUpdate() {}
/* Not called on initial render() */
/* Called after every component's updates are flushed to DOM i.e. on every re-render i.e. on every state change (using .setState) or from changes of props */

- componentWillUnmount() {}
/* similar to ngOnDestroy() */
/* Called when component is to be destroyed */



COMPOSABLE COMPONENTS   (similar to *ngFor in angular)
========================
/* 1. AllCommentsPage.js */
import React from "react";
import CommentList from "./CommentList";
import CommentApi from "../data/CommentApi";
export default class AllCommentsPage extends React.Component {    
   constructor(props) {
      super(props);
      this.state = {
         comments: []
      };
   }    
   componentDidMount() {
      this.setState({ comments: CommentApi.getAllComments() });    
   }    
   render() {
      return (            
         <>                
	 <h1>Comments</h1>                
	 <CommentList comments={this.state.comments} />            
	 </>        
      );    
   }
}

/* 2. CommentList.js */
/* Instead of <Comment> component , it can be a simple HTML tag too */
/* `key` is a mandatory reserved ReactJS keyword whose value is unique , to uniquely identify each component amongst composable components */
import React from 'react';
import Comment from './Comment';
export default class CommentList extends React.Component {  
   render () {
      let commentNodes = this.props.comments.map((comment) => {
         return (
	    <Comment key={comment.id} author={comment.author}> 
	       {comment.text} 
	    </Comment>    
	 );
      });    
      return (      
         <>        
         <table>          
            <thead>            
	       <tr>              
	          <th>Author</th>              
		  <th>Comment</th>            
	       </tr>          
	    </thead>          
	    <tbody>            
	       {commentNodes}          
	    </tbody>        
	 </table>      
	 </>    
      );  
   }
}

/* 3.  Comment.js */
import React from 'react';
export default class Comment extends React.Component {  
   render() {    
      return (    
         <>
         <tr>          
	    <td>{this.props.author}</td>          
	    <td>{this.props.children}</td>        
	 </tr> 
	 </>
      );  
   }
}



HIGHER ORDER COMPONENTS    |    RENDER PROPS
============================================
/* They are used for rendering common portion of components implementation */
/* HIGHER ORDER COMPONENTS (HOC) */
/* It use a function ( example : withItem() ) that takes a component as parameter and returns a new component */
/* 1. App.js */
import React, { Component } from 'react';
import EmployeeListHOC from './components/EmployeeList';
import CustomerListHOC from './components/CustomerList';
class App extends Component {
    render() {
        return (
            <>
                <EmployeeListHOC heading="Employee List (Higher Order Component)"/>
                <CustomerListHOC heading="Customer List (Higher Order Component)"/>
            </>
        )
    }
}
export default App;

/* 2. withItem.js */
import React, { Component } from 'react';
const withItem = (WrappedComponent, toUpper) => {
    class WithItem extends Component {
        constructor(props) {
            super(props);
            this.state = {
                itemInputted: '',
                items: []
            }
        }
        handleItemInput = (e) => {
            this.setState({itemInputted: e.target.value})
        }
        addItem = (itemName) => {
            this.setState(prevState => {
                return { items: [...prevState.items, toUpper ? itemName.toUpperCase() : itemName] };
            })
        }
        render() {
            return (
                <WrappedComponent
                    itemInputted={this.state.itemInputted}
                    handleItemInput={this.handleItemInput}
                    items={this.state.items}
                    addItem={this.addItem}
                    {...this.props} />                                          // destructuring props , passed from parent component , here `App.js`
            )
        }
    }
    return WithItem;
}
export default withItem;

/* 3. EmployeeList.js */
import React, { Component } from 'react';
import withItem from './withItem';
class EmployeeList extends Component {
    render() {
        const { itemInputted, handleItemInput, items, addItem } = this.props; // DESTRUCTURING - ES2015 concept
        let itemList = items.map((item, index) => (
            <li key={index}>{item}</li>
        ))
        return (
            <>
                <h2>{this.props.heading}</h2>
                <label>
                    Enter employee name:
                    <input type="text" value={itemInputted} onChange={(e) => handleItemInput(e)} />
                </label>
                <button onClick={() => addItem(itemInputted)}>Add Employee (HOC)</button>
                <ul>
                    {itemList}
                </ul>
            </>
        )
    }
}
// Arguments can be passed accordingly to withItem function that handle common code for different components.
// here `true` is passed to store name as uppercase
export default withItem(EmployeeList, true);

/* 4. CustomerList.js */
import React, { Component } from 'react';
import withItem from './withItem';
class CustomerList extends Component {
    render() {
        const { itemInputted, handleItemInput, items, addItem } = this.props;  // DESTRUCTURING - ES2015 concept
        let itemList = items.map((item, index) => (
            <li key={index}>{item}</li>
        ))
        return (
            <>
                <h2>{this.props.heading}</h2>
                <label>
                    Enter customer name:
                    <input type="text" value={itemInputted} onChange={(e) => handleItemInput(e)} />
                </label>
                <button onClick={() => addItem(itemInputted)}>Add Customer (HOC)</button>
                <ul>
                    {itemList}
                </ul>
            </>
        )
    }
}
// Arguments can be passed accordingly to withItem function that handle common code for different components.
// here `false` is passed to store name as uppercase
export default withItem(CustomerList, false);


/* RENDER PROPS */
/* A render prop is where a components prop is assigned a function and this is called in render() method of component */
/* 1. App.js */
import React, { Component } from 'react';
import Item from './components/Item';
import EmployeeList from './components/EmployeeList';
import CustomerList from './components/CustomerList';
class App extends Component {
    render() {
        return (
            <>
                <Item isUpper={true}>
                    {(itemInputted, handleItemInput, items, addItem) => (
                        <EmployeeList 
                            itemInputted={itemInputted}
                            handleItemInput={handleItemInput}
                            items={items}
                            addItem={addItem}
                            heading="Employee List (Using Render Props)" />
                    )}
                </Item>
                <Item>
                    {(itemInputted, handleItemInput, items, addItem) => (
                        <CustomerList
                            itemInputted={itemInputted}
                            handleItemInput={handleItemInput}
                            items={items}
                            addItem={addItem}
                            heading="Customer List (Using Render Props)" />
                    )}
                </Item>
            </>
        )
    }
}
export default App;

/* 2. Item.js */
import React, { Component } from 'react';
class Item extends Component {
    constructor(props) {
        super(props);
        this.state = {
            itemInputted: '',
            items: []
        }
    }
    handleItemInput = (e) => {
        this.setState({itemInputted: e.target.value})
    }
    addItem = (itemName) => {
        this.setState(prevState => {
            return { items: [...prevState.items, this.props.isUpper ? itemName.toUpperCase() : itemName] };
        })
    }
    render() {
        return (
            <div>
                {this.props.children(this.state.itemInputted, this.handleItemInput, this.state.items, this.addItem)}
            </div>
        )
    }
}
export default Item;

/* 3. EmployeeList.js */
import React, { Component } from 'react';
class EmployeeList extends Component {
    render() {
        const { itemInputted, handleItemInput, items, addItem } = this.props;
        let itemList = items.map((item, index) => (
            <li key={index}>{item}</li>
        ))
        return (
            <>
                <h2>{this.props.heading}</h2>
                <label>
                    Enter employee name:
                    <input type="text" value={itemInputted} onChange={(e) => handleItemInput(e)} />
                </label>
                <button onClick={() => addItem(itemInputted)}>Add Employee (RP)</button>
                <ul>
                    {itemList}
                </ul>
            </>
        )
    }
}
export default EmployeeList;

/* 4. CustomerList.js */
import React, { Component } from 'react';
class CustomerList extends Component {
    render() {
        const { itemInputted, handleItemInput, items, addItem } = this.props;
        let itemList = items.map((item, index) => (
            <li key={index}>{item}</li>
        ))
        return (
            <>
                <h2>{this.props.heading}</h2>
                <label>
                    Enter customer name:
                    <input type="text" value={itemInputted} onChange={(e) => handleItemInput(e)} />
                </label>
                <button onClick={() => addItem(itemInputted)}>Add Customer (RP)</button>
                <ul>
                    {itemList}
                </ul>
            </>
        )
    }
}
export default CustomerList;



HTTP SERVICE using AXIOS
===========================
>  npm install axios
/* REFERENCE : https://github.com/axios/axios */
/* It is a Promise based HTTP client lib for browser and node.js */
/* Provides API for HTTP verbs , similar to HTTPClientModule in angular */

GET REQUEST
-----------------------
axios.get('/user', {
    params: {               // query params
      ID: 12345
    }
  })
  .then((response) => {
    console.log(response);  // handle success
  })
  .catch((error) => {
    console.log(error);     // handle error
  })
  .then(() => {
    console.log(`API CALL COMPLETED`);      // always executed similar to 'finally'
  });
  
POST REQUEST
-------------------------
axios.post('/user', {
    firstName: 'Fred',                      // POST req BODY
    lastName: 'Flintstone'
  })
  .then((response) => {
    console.log(response);
  })
  .catch((error) => {
    console.log(error);
  })
  .then(() => {  
    console.log(`API CALL COMPLETED`);     // always executed similar to 'finally'
  });
  
RESPONSE for a request contains the following information
------------------------------------------------------------------------------
{
  // `data` is the response BODY that was provided by the server
  data: {},

  // `status` is the HTTP status code from the server response
  status: 200,

  // `statusText` is the HTTP status message from the server response
  statusText: 'OK',

  // `headers` the HTTP headers that the server responded with
  // All header names are lower cased and can be accessed using the bracket notation.
  // Example: `response.headers['content-type']`
  headers: {},

  // `config` is the config that was provided to `axios` for the request
  config: {},

  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance in the browser
  request: {}
}

Handling Errors
-------------------------
axios.get('/user/12345')
  .catch((error) => {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
      throw error;
    } else if (error.request) {
      // The request was made but no response was received
      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
      // http.ClientRequest in node.js
      console.log(error.request);
      throw error;
    } else {
      // Something happened in setting up the request that triggered an Error
      console.log('Error', error.message);
      console.log(error.config);
      throw error;
    }
  });

/* EXAMPLE: .service.js */
import axios from 'axios';
export default class CommentApi {
   static getAllComments(cbFn) {
      axios.get('http://localhost:3000/comments')
           .then((response) => {
	      return cbFn(response.data);
	    })
	   .catch((error) => { 
	      throw error;
	    })
	    .then(() => {
	       console.log(`API CALL COMPLETED`);
	    });
   }
}

/* EXAMPLE:  .comp.js */
import React from 'react';
import CommentList from './CommentList';
import CommentApi from '../data/CommentApi';
export default class AllCommentsPage extends React.Component {    
   constructor(props) {      
      super(props);      
      this.state = {        
         comments: []      
      };    
   }    
   componentDidMount() {      
      CommentApi.getAllComments((resDATA) => { 
         this.setState((prevState) => {
	    return {comments: [...prevState.comments, ...resDATA]}
	 });  
      });
   }    
   render() {      
      return (        
         <>            
	 <h1>Comments</h1>            
	 <CommentList comments={this.state.comments} />        
	 </>      
      );    
   }
}



FORM HANDLING using FORMIK and YUP
==================================
> npm install formik
> npm install yup
/* FORMIK is a library for form handling , It can be implemented as RENDER PROPS (preferred)  or  HIGHER ORDER COMPONENTS (HOC) */
/* YUP provides a variety of schema types for validation */
/* NOTE : Common functionalities in any form */
   /* 
       - Setting of initial value in form
       - Event handling for various form fields
       - Validation
       - Handling form submission
   */
/*
 - `name` attributes of HTML element acts as `keys` for FORMIK.
 -  use of  initialValues={{key1: "", key2: ""}}
 -  use of  enableReinitialize={true}  for resetting the form with new values if initialValues changes.
 -  use of  <Form></Form>   from FORMIK instead of HTML tag <form></form> because it will automatically handle onSubmit event for it.
 -  use of  <Field></Field>    from FORMIK instead of HTML tag <input></input> because it will automatically handle initial values and onChange event for it.
 -  use of  validationSchema   from YUP to handle Form constraints like required , min , max , trim    etc....
 -  use of `errors` and `touched` props from FORMIK  , similar to touched | untouched , dirty | pristine , valid | invalid in Angular.
*/
/*
 REFERENCE : https://jaredpalmer.com/formik/docs/api/formik
*/



ROUTING
==========
> npm install react-router-dom
 - `BrowserRouter` provides routing functionality to a component.

 - `Switch` is similar to switch in C/CPP to render a component as of path specified. 

 - `Route` accepts arguments:
     - path={`/user`}
     - component={COMPONENT} 
     - exact				=>     It is recommended to use exact argument for full matching ,
				         otherwise  for example :   '/user' and '/user/edit'   will render component for /user always if it's `Route` appears before /user/edit  in `Switch`
    - path={`*`}			=>     similar to path = `**` in Angular , for default case i.e. Nothing match or page not found

 - `Redirect` accepts arguments:
    - to={`/user`}			=>     This is path of one of the existing `Route` in `Switch`

 - `NavLink` is used in NavBar which accepts arguments:
    - to={`/user`}				=>     similar to `routerLink`
    - activeClassName={`CSS_CLASS`}		=>     similar to `routerLinkActive`
    - exact					=>    similar to `routerLinkActiveOptions`

 - `Link` is similar to <a></a> anchor tag in HTML , but provides application routing whereas 'href' will provide browser routing.
    - to={`/user/edit/${id}`}

 -  `withRouter` provides HOC functionality to our component and provides functionality to navigate to a specific route using history prop.
      history is an array of visited locations , 'push' will add a new location to the array and 'replace' will replace the current location in the array with the new one.
    - this.props.history.push(`/`);                   
    - this.props.history.replace(`/`);       

 -  PATH PARAMETERS
    in `Route` for path arg specify path for parameter using  ':' ( colon ) ,	path={`/edit/:VAR`}
    to retrieve it's value in component , use 				this.props.match.params.VAR    
	 

Route transitions
-------------------------
It is of two types and are similar to RouteGuard concept in Angular.
 - Transition IN		=>      similar to `canActivate`
 - Transition OUT		=>      similar to `canDeactivate`

Transition IN is checked in 'constructor() { }' 

Transition OUT is handled via <Prompt />  from  'react-router-dom'  in 'render() {}' , it accepts arguments:
 - when={this.state.modified}
 - message={`Are you sure to leave`}

/* Example */
import React from 'react';
import {withRouter, Prompt} from 'react-router-dom';
class CommentDetail extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      modified: false
    };

    this.authenticate(props.history);
  }

  authenticate(history) {
    let authenticated = window.confirm('Press OK to Login');
    if (!authenticated) {
      alert("Not authenticated, hence redirecting back...");
      history.replace('/');
    }
    else {
      alert("Authenticated, hence proceeding ahead and displaying the details.")
    }
  }

  setModified() {
    this.setState({modified: true})
  }

  render() {
    return (
      <div>
        <label>ID: </label>
        <input type="text" defaultValue={this.props.match.params.id} onInput={() => this.setModified()}/>
        <Prompt when={this.state.modified} message="Are you sure you want to leave ?" />
      </div>
    );}
}
export default withRouter(CommentDetail);



FLUX
======
NOTE : It's always recommended to use FLUX within our applications.

It's a principle based on unidirectional flow.
	"ANYTHING on VIEW must follow ACTION DISPATCHER flow"

Applications might demand new features to be added, which require their testing.
FLUX provides a maintainability of these features.
It uses a FLUX ARCHITECTURE.

IT HAS A DEFINED DIR STRUCTURE
-------------------------------
 "ACTIONS" dir
	Dispatch , action type  and  payload (data , optional but not always)

 "COMPONENTS" dir
	REACT Components.

 "CONSTANTS" dir
	constants for action types strings.

 "DISPATCHER" dir
	export Dispatcher class.
	Dispatches actions to all STORES.

 "STORES" dir
	Dispatcher registers here.
	update internal structure and inform view about change.
	STORE is a publisher and VIEW is a subscriber.



REACT-BOOTSTRAP
====================
> npm install react-bootstrap bootstrap

1. index.js
----------------
/* include this before other CSS imports for local styles to get preference over default bootstrap styles */
import 'bootstrap/dist/css/bootstrap.min.css';

2. COMPONENT.js
----------------------------
import Button from 'react-bootstrap/Button';
import './COMPONENT.css';
<Button variant="danger" onClick={(evt) => this.decCounter(evt)}>Decrement Counter</Button>


STYLE
=========== 
NOTE : 'className' attr is used and not 'class' attr is used in HTML tags for CSS because 'class' is a reserved JS keyword.
	example:
		<div className={`CLASS_NAME_1 CLASS_NAME_2`}>  ...  </div>
	
- Conditional assignment of CSS Classes
  Here CLASS_NAME_1 , CLASS_NAME_2 are always applied on DIV , however CLASS_1 and CLASS_2 are applied or toggled accordingly.
  example:
  	  <div className={`CLASS_NAME_1 CLASS_NAME_2 ${this.state.VAR1 ? "CLASS_1" : ""} ${this.state.VAR2 == "VAL" ? "CLASS_1" : "CLASS_2"}`}>
	  ...
	  </div>



